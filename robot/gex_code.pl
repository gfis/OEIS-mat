#!perl

# Parse general expressions in output of gex_oeis.pl
# @(#) $Id$
# 2024-05-30, Georg Fischer: copied from gex_oeis.pl
#
#:# Usage:
#:#   perl gex.oeis.pl ... \
#:#   | perl gex_parse.pl > seq4-format 2> rest
#--------------------------------------------------------
use strict;
use integer;
use warnings;
my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime (time);
my $timestamp = sprintf ("%04d-%02d-%02d %02d:%02d", $year + 1900, $mon + 1, $mday, $hour, $min);
my $pwd = `pwd`;
$pwd =~ m{(/OEIS\-mat\S*)};
print "# Generated by ..$1/$0 at $timestamp\n";
my $debug = 0;
if (0 && scalar(@ARGV) == 0) {
    print `grep -E "^#:#" $0 | cut -b3-`;
    exit;
}
while (scalar(@ARGV) > 0 and ($ARGV[0] =~ m{\A[\-\+]})) {
    my $opt = shift(@ARGV);
    if (0) {
    } elsif ($opt  =~ m{d}) {
        $debug     = shift(@ARGV);
    } else {
        die "invalid option \"$opt\"\n";
    }
} # while $opt

my ($line, $aseqno, $callcode, $offset1, $name, @rest);
while (<DATA>) {
# while (<>) {
    next if !m{\AA\d+}; # must start with A-number
    $line = $_;
    $line =~ s/\s+\Z//; # chompr
    my $nok = 0;
    ($aseqno, $callcode, $offset1, $name, @rest) = split(/\t/, $line);
    if ($debug >= 2) {
        print "#----------------\n# $line\n";
    }
    $name =~ s{ }{}g; # remove all spaces

    my @list = ();
    my $ilist = 0; # next index for list elements
    my $list_len = scalar(@list) - 1;
    my $source; # text to be replaced
    my $qsource; # quatemeta($source);
    my $target; # replacement text
    my $loop_check = 64;
    while (--$loop_check >= 0 && $list_len < scalar(@list)) { # at the start, or something has still been added
        if ($debug >= 1) { print "#   name=$name, ilist=$ilist, list=" . join(";", @list) . "\n"; }
        $list_len = scalar(@list);
        #---- (A)-number call ----
        #                   12           2  3   3  1
        if ($name =~ m{(([ADFK]\d{6})\((\w+)\))}) {
                $source = $1; $qsource = quotemeta($1);
                $target = "_ZA$ilist";
                push(@list, "$target=$source"); $ilist = scalar(@list); 
                $name =~ s{$qsource}{$target}g;
        }
        #---- (P)roduct, separated by "*" ----
        #                   1   2     2 1
        if (index($name, "*") >= 0) {
            if ($name =~ m{(\w+(\*\w+)+)}) {
                $source = $1; $qsource = quotemeta($1);
                my @flist = (); # factors in the order _C, _Q, _Z, _i
                my %factors = ();
                my $factor;
                map {
                    $factor = $_;
                    if ($factor =~ m{[i-n]}) { 
                        $target = "_i$ilist"; # typify integer variables i-n
                        push(@list, "$target=$factor"); $ilist = scalar(@list); 
                        $factor = $target;
                    }
                    $factors{$factor} = 1;
                    $_
                    } split(/\*/, $1);
                my $ifact = 0;
                my $product = "";
                foreach $factor (sort(keys(%factors))) {
                    if ($ifact == 0) {
                        $product .= $factor;
                    } else {
                        $product .= ".*($factor)";
                    }
                    $ifact ++;
                }
                $target = "_Z$ilist";
                push(@list, "$target=$product"); $ilist = scalar(@list); 
                $name =~ s{$qsource}{$target}g;
            }
        } # with "*"
    } # main substitution loop

    if ($loop_check <= 0) {
        $nok = "1loop";
    }
    if ($name =~ m{\A_[CQZij]\d+\Z}) { # all substituted
    } else { # some unparsed rest remained
        $nok = "2npar";
    }

    if ($nok eq "0") {
        print        join("\t", $aseqno, "lambda"     , 0, "$name", join(";", @list), join("\t", @rest)) . "\n";
    } else {
        print STDERR join("\t", $aseqno, "#not=$nok"  , 0, "$name", join(";", @list), join("\t", @rest)) . "\n";
    }
} # while <>
#--------------------------------------------
__DATA__
A076090	lambda	0	A072408(n)	\\	a(n)=A072408(n), n>1. [From _R. J. Mathar_, Sep 23 2008]
A072241	lambda	0	A000009(A000045(n))	\\	a(n) = A000009(A000045(n)).
A900001	lambda	0	n*k
A900002	lambda	0	n*k*i*j
A123456	lambda	0	n*A900001(n)

