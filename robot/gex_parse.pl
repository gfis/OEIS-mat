#!perl

# Parse general expressions in output of gex_oeis.pl
# @(#) $Id$
# 2024-05-31, Georg Fischer: copied from gex_oeis.pl
#
#:# Usage:
#:#   perl gex_oeis.pl ... \
#:#   | perl gex_parse.pl -d debugmode [-s] > seq4-format 2> rest
#:#     -d debugging mode
#:#     -s sort by decreasing number system complexity (real, rational, long, integer)
#:#

# Placeholders have the form "_<type><code><iseq>", where
#   type (caution: sort order must be decreasing number system complexity)
#     C ComputableReals
#     Q Rationals
#     Z Integers
#     l long
#     n int
#   code (all operand lists are separated by ",")
#     A list of summands to be separated by "+", sorted
#     B operand to be enclosed in "(...)"
#     C function call: name, list of parameters
#     D list of dividend and divisors to be separated by "/", sorted
#     E list of base and exponents to be separated by "^"
#     F factorial: operand and number (1 = "!", 2 = "!!" ...)
#     I integer number (without sign)
#     M list of multiplicants to be separated by "*", sorted
#     N operand to be negated
#     P product: loop variable, start, end
#     S sum:     loop variable, start, end
#     V variable
#   iseq: sequential number, index in list
#--------------------------------------------------------
use strict;
use integer;
use warnings;
my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime (time);
my $timestamp = sprintf ("%04d-%02d-%02d %02d:%02d", $year + 1900, $mon + 1, $mday, $hour, $min);
my $pwd = `pwd`;
$pwd =~ m{(/OEIS\-mat\S*)};
print "# Generated by ..$1/$0 at $timestamp\n";
if (0 && scalar(@ARGV) == 0) {
    print `grep -E "^#:#" $0 | cut -b3-`;
    exit;
}

my $debug = 0;
my $sorted = 0;
while (scalar(@ARGV) > 0 and ($ARGV[0] =~ m{\A[\-\+]})) {
    my $opt = shift(@ARGV);
    if (0) {
    } elsif ($opt  =~ m{d}) {
        $debug     = shift(@ARGV);
    } elsif ($opt  =~ m{s}) {
        $sorted    = 1;
    } else {
        die "invalid option \"$opt\"\n";
    }
} # while $opt

my %known_constants = qw(
e           CR.E
pi          CR.PI
phi         CR.PHI
eulergamma  CR.GAMMA
googol      Z.TEN.pow(100)
);
my ($line, $aseqno, $callcode, $offset1, $name);
my @rest;
my @list = ();
my $ilist = scalar(@list); # this is the contract: index for next list elements
my $old_list_len = scalar(@list) - 1;
my $loop_check = 32;
my $source;
my $tuple;
my $type;
my $nok;

# while (<DATA>) {
while (<>) {
    next if !m{\AA\d+}; # must start with A-number
    $line = $_;
    $line =~ s/\s+\Z//; # chompr
    $nok = 0;
    ($aseqno, $callcode, $offset1, $name, @rest) = split(/\t/, $line);
    if ($debug >= 1) {
        if ($debug >= 2) {
            print "#----------------\n# ";
        }
        print join("\t", $aseqno, $callcode, $offset1, $name, join("\t", @rest)) . "\n";
    }
    $name =~ s{ }{}g; # remove all spaces

    @list = ();
    $ilist = 0; # next index for list elements
    $old_list_len = - 1;
    $loop_check = 32;
    while (--$loop_check >= 0 && $old_list_len < scalar(@list)) { # at the start, or something has still been added
        $old_list_len = scalar(@list);
        #---- (A)ddition list separated by "+" and/or "-"
        #                  1      2         2 1
        while (($name =~ m{(\-?\w+([\+\-]\w+)+)})) {
            $source = $1;
            ($type, $tuple) = &typify(&insert_negations($source), ",", 1); # separators replaced by insert_negations
            $name = &insert_placeholder($name, $source, $type, $tuple, "A");
        }
        #---- (C)all of a function, with optional commata
        #                                            12                    2  34   45     5 3  1
        while (index($name, "(") >= 0 && ($name =~ m{(([A-Za-z][A-Za-z0-9]*)\(((\w+)(\,\w+)*)\))})) {
            $source = $1;
            my $fname = $2;
            ($type, $tuple) = &typify($3, ",", 0);
            ($type, $tuple) = &create_function_call($type, $fname, $tuple);
            $name = &insert_placeholder($name, $source, $type, $tuple, "C");
        }
        #---- (B)rackets (no commata; must be tested after "C" function calls)
        #                                            1  2   2  1
        while (index($name, "(") >= 0 && ($name =~ m{(\((\w+)\))})) {
            $source = $1;
            ($type, $tuple) = &typify($2 , ",", 0);
            $name = &insert_placeholder($name, $source, $type, $tuple, "B");
        }
        #---- (D)ivision list separated by "/"
        #                                            1   2     2 1
        while (index($name, "/") >= 0 && ($name =~ m{(\w+(\/\w+)+)})) {
            $source = $1;
            ($type, $tuple) = &typify($source , "/", 0);
            if ($type =~ m[ln]) { # (int|long)/n yields "Q"
                $type = "Q";
            }
            $name = &insert_placeholder($name, $source, $type, $tuple, "D");
        }
        #---- (E)ponentiation: list separated by "^"
        #                                            1   2     2 1
        while (index($name, "^") >= 0 && ($name =~ m{(\w+(\^\w+)+)})) {
            $source = $1;
            ($type, $tuple) = &typify($source , "^", 0);
            if ($type =~ m[ln]) { # (int|long)^n yields "Z"
                $type = "Z";
            }
            $name = &insert_placeholder($name, $source, $type, $tuple, "E");
        }
        #---- (F)actorial followed by one or more "!" signs
        #                                            12   23   31
        while (index($name, "!") >= 0 && ($name =~ m{((\w+)(\!+))})) {
            $source = $1;
            my $expon = length($3);
            ($type, $tuple) = &typify($2, ",", 0);
            $name = &insert_placeholder($name, $source, "Z", "$tuple,$expon", "F"); # Factorial always yields Z
        }
        #---- (M)ultiplication list separated by "*"
        #                                            1   2     2 1
        while (index($name, "*") >= 0 && ($name =~ m{(\w+(\*\w+)+)})) {
            $source = $1;
            ($type, $tuple)  = &typify($source, "*", 1);
            $name = &insert_placeholder($name, $source, $type, $tuple, "M");
        }
        #---- (P)roduct: list separated by "*"
        # nyi                                        1   2     2 1
        while (0 && index($name, "*") >= 0 && ($name =~ m{(\w+(\*\w+)+)})) {
            $name = &insert_placeholder($name, $source, $type, $tuple, "P");
        }
        #---- (S)um: 
        # nyi              1      2         2 1
        while (0 && ($name =~ m{(\-?\w+([\+\-]\w+)+)})) {
            $name = &insert_placeholder($name, $source, $type, $tuple, "S");
        }
        #-------- (I) single number
        #                1   2     21
        if ($name =~ m{\A(\d+|\d*(\.\d+))\Z}) {
            $source = $1;
            ($type, $tuple) = &typify($source , ",", 0);
            $name = &insert_placeholder($name, $source, $type, $tuple, "I");
        }
        #-------- (V) single variable name
        #                1                    1
        if ($name =~ m{\A([A-Za-z][A-Za-z0-9]*)\Z}) {
            $source = $1;
            ($type, $tuple) = &typify($source , ",", 0);
            $name = &insert_placeholder($name, $source, $type, $tuple, "V");
        }
        #--------
    #   if ($debug >= 3) {
    #       print "#      old_list_len=$old_list_len, scalar(\@list)=" . scalar(@list) . "\n";
    #   }
    } # main substitution loop

    # In the end, the name will be reduced to a single placeholder
    # iff the expression was parsed completely.
    if ($name =~ m{\A_[A-Za-z]+\d+\Z}) { # all substituted
    } else { # some unparsed rest remained
        $nok = "2npar";
    }
    if ($loop_check <= 0) {
        $nok = "1loop";
    }
    if ($nok eq "0") {
        print        join("\t", $aseqno, "$callcode"  , 0, join(";", @list), $name, @rest) . "\n";
    } else {
        print STDERR join("\t", $aseqno, "#nok=$nok"  , 0, join(";", @list), $name, @rest) . "\n";
    }
} # while <>
#----
sub typify { 
    my ($tuple, $sep, $order) = @_;
    # insert placeholders for elementary variable names and numbers
    # return the placeholder with the lowest type and the tuple
    # optionally order by ascending types
    # replace the separator by comma
    $sep = quotemeta($sep);
    my $min_type = "zz"; # very high
    my $placeholder;
    my $type;
    my @elems = ();
    foreach my $elem (split(/$sep/, $tuple)) {
        if (substr($elem, 0, 1) ne "_") { # no placeholder yet
            if (0) {
            } elsif ($elem =~ m{\A[i-n]\Z}) { # simple variable for int
                $placeholder = "_nV$ilist";
                push(@list, "$placeholder=$elem"); $ilist = scalar(@list);
                $elem = $placeholder
            } elsif ($elem =~ m{\A[A-Za-z][A-Za-z0-9]*\Z}) { # simple known real variable
                $placeholder = "_CV$ilist";
                $elem = uc($elem);
                if (defined($known_constants{lc($elem)})) {
                    $elem = $known_constants{lc($elem)};
                } else {
                    $nok = "4un=$elem";
                }
                push(@list, "$placeholder=$elem"); $ilist = scalar(@list);
                $elem = $placeholder;
            } elsif ($elem =~ m{\A[0-9\.]+\Z}) { # natural or decimal number
                my $len = length($elem);
                if (0) {
                } elsif ($elem =~ m{\.}) { # decimal point
                    $type = "C"; # ComputableReal
                } elsif ($len >= 18) {
                    $type = "Z"; # Integers
                } elsif ($len >= 9) {
                    $type = "l"; # long
                } else {
                    $type = "n"; # int
                }
                $placeholder = "_$type" ."I$ilist";
                push(@list, "$placeholder=$elem"); $ilist = scalar(@list);
                $elem = $placeholder
            } else { # unknown elementary primary
                $nok = "2un=$elem";
            }
        }
        if ($elem lt $min_type) { # lower
            $min_type = $elem;
        }
        push(@elems, $elem);
    } # for @elems
    return (substr($min_type, 1, 1), join(",", ($order != 0) ? sort(@elems) : @elems)); # always comma separated
} # typify
#----
sub insert_placeholder {
    my ($name, $source, $type, $tuple, $code) = @_;
    my $placeholder = "_$type$code$ilist";
    push(@list, "$placeholder=$tuple"); $ilist = scalar(@list);
    my $qsource = quotemeta($source);
    $name =~ s{$qsource}{$placeholder}g;
    if ($debug >= 2) {
        print "#   name=\"$name\" list=\"" . join(";", @list) . "\" [$ilist]\n";
    }
    return $name;
} # insert_placeholder
#----
sub insert_negations {
    my ($tuple) = @_;
    my $old_tuple = $tuple;
    my @elems = split(/([\+\-])/, $tuple); # "/(..)/" yields the delimiters, too!
    $tuple = "";
    my $ielem = 0; 
    while ($ielem < scalar(@elems)) {
        my $elem = $elems[$ielem];
        if (0) {
        } elsif ($elem eq "+") { # ignore
        } elsif ($elem eq "-") { # replace next element by its negation
            $ielem ++;
            my ($type, $tuple1) = &typify($elems[$ielem], ",", 0);
            my $placeholder = "_$type" . "N$ilist"; # (N)egation
            push(@list, "$placeholder=$elems[$ielem]"); $ilist = scalar(@list); 
            $tuple .= ",$placeholder";
        } else { # +summand - typify later
            $tuple .= ",$elem";
        }
        $ielem ++;
    } # while $ielem
    if ($debug >= 2) {
        print "#   insert_negations: old_tuple=$old_tuple, tuple=$tuple, list: " . join(";", @list) . " [$ilist]\n";
    }
    return substr($tuple, 1); # remove leading ","
} # insert_negations
#----
sub create_function_call {
    my ($type, $fname, $tuple) = @_;
#    my $placeholder = "_$type$code$ilist";
#    push(@list, "$placeholder=$tuple"); $ilist = scalar(@list);
#    my $qsource = quotemeta($source);
#    $name =~ s{$qsource}{$placeholder}g;
#    if ($debug >= 2) {
#        print "#   name=\"$name\" list=\"" . join(";", @list) . "\" [$ilist]\n";
#    }
    return ($type, $tuple);
} # create_function_call
#--------------------------------------------
__DATA__
A900001	lambda	0	n*k                  	n>= 0	n*k                  	
A900002	lambda	0	n*k*i*j              	n>= 0	n*k*i*j              	

A900011	lambda	0	n+k-i+j              	n>= 0	n+k-i+j              	
A900012	lambda	0	-n+k-i+j             	n>= 0	-n+k-i+j             	
A900013	lambda	0	n+k-(i+j)            	n>= 0	n+k-(i+j)            	
A900014	lambda	0	(-n+k)-(i-j          	n>= 0	(-n+k)-(i-j          	
A900015	lambda	0	-(n+k)-(i+j)         	n>= 0	-(n+k)-(i+j)         	
A900016	lambda	0	-n-(i-j-k)           	n>= 0	-n-(i-j-k)           	

A900024	lambda	0	n^2                  	n>= 0	n^2                  	
A900025	lambda	0	i^j^k                	n>= 0	i^j^k                	
A900034	lambda	0	34!                  	n>= 0	34!                  	
A900035	lambda	0	35!!!!               	n>= 0	35!!!!               	
A900036	lambda	0	n!                   	n>= 0	n!                   	
A900037	lambda	0	n!!!                 	n>= 0	n!!!                 	
A900038	lambda	0	(n+1)!               	n>= 0	(n+1)!               	
A900039	lambda	0	((n+1)!)!            	n>= 0	((n+1)!)!            	
A900041	lambda	0	n/k                  	n>= 0	n/k                  	
A900042	lambda	0	n/i/j                	n>= 0	n/i/j                	

A900050	lambda	0	sin(x)               	n>= 0	sin(x)               	
A900051	lambda	0	valuation(n,17)      	n>= 0	valuation(n,17)      	
A900052	lambda	0	binomial(n,k)        	n>= 0	binomial(n,k)        	
A900053	lambda	0	A123456(n)           	n>= 0	A123456(n)           			any A-number
A900054	lambda	0	A000005(n)           	n>= 0	A000005(n)           	Functions.TAU.z
A900055	lambda	0	D006519(n + 2)       	n>= 0	D006519(n + 2)       	DirectSequence

A900061	lambda	0	12345678             	n>= 0	12345678             	int
A900062	lambda	0	123456789            	n>= 0	123456789            	long
A900063	lambda	0	1234567890           	n>= 0	1234567890           	long
A900064	lambda	0	12345678901234567    	n>= 0	12345678901234567    	long
A900065	lambda	0	123456789012345678   	n>= 0	123456789012345678   	Z
A900066	lambda	0	1234567890123456789  	n>= 0	1234567890123456789  	Z
A900067	lambda	0	12345678901234567.0  	n>= 0	12345678901234567.0  	CR
A900071	lambda	0	n                    	n>= 0	n                    	
A900072	lambda	0	e                    	n>= 0	e                    	
A900073	lambda	0	Pi                   	n>= 0	Pi                   	
A900074	lambda	0	EulerGamma           	n>= 0	EulerGamma           	

A900081	lambda	0	(n + 1)              	n>= 0	(n + 1)              	brackets
A900082	lambda	0	(n + 1)*(n+2)        	n>= 0	(n + 1)*(n+2)        	brackets
A900083	lambda	0	((n + 1)*3)*(n+2)    	n>= 0	((n + 1)*3)*(n+2)    	brackets

A076090	lambda	0	A072408(n)	\\	a(n)=A072408(n), n>1. [From _R. J. Mathar_, Sep 23 2008]
A072241	lambda	0	A000009(A000045(n))	\\	a(n) = A000009(A000045(n)).
A123456	lambda	0	n*A900001(n)
A076276	lambda	0	A006128(n-1) + A182699(n)	\\	a(n) = A006128(n-1) + A182699(n), n >= 1. - _Omar E. Pol_, Oct 30 2011
A076277	lambda	0	A066637(n) - A001055(n)	\\	a(n) = A066637(n) - A001055(n) for n > 1. - _Henry Bottomley_, Oct 10 2002
A076304	lambda	0	sqrt(prime(i) + prime(i+1) + prime(i+2)) 	\\	a(n) = sqrt(prime(i) + prime(i+1) + prime(i+2)) where i = €076305(n). [Corrected by _M. F. Hasler_, Jan 03 2020]
A076357	lambda	0	floor(t^n) 	\\	a(n) = floor(t^n) where n=39661481813^(1/10) (approximately 11.4772). a(n) is prime for n<=10.
A076360	lambda	0	d0(d1(w)) - d1(d0(w))	\\	a(n) = d0(d1(w)) - d1(d0(w)), where d0()=number of divisors, d1()=sum of divisors.
A076448	lambda	0	2^(2^(n-2)+n-1)+1	\\	a(n) =2^(2^(n-2)+n-1)+1 = A000051(A005126(n-2)).
A076530	lambda	0	A065900(n) - 1 = A104149(n) + 1	\\	a(n) = A065900(n) - 1 = A104149(n) + 1. - _Alex Ratushnyak_, Jul 06 2013
A076544	lambda	0	mu(n) + -1^(1+abs(mu(n)))	\\	a(n) = mu(n) + -1^(1+abs(mu(n))), where mu(n) = A008683(n). - _Antti Karttunen_, Jul 26 2017


