#!perl

# Prepare CR equations: extract X-numbers from parm1 to parm2
# @(#) $Id$
# 2024-06-05, Georg Fischer
#
#:# Usage:
#:#   perl equals_prepare.pl [-d debug] input.seq4 > output.seq4
#--------------------------------------------------------
use strict;
use integer;
use warnings;
my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime (time);
my $timestamp = sprintf ("%04d-%02d-%02d %02d:%02d", $year + 1900, $mon + 1, $mday, $hour, $min);
my $pwd = `pwd`;
$pwd =~ m{(/OEIS\-mat\S*)};
print "# Generated by ..$1/$0 at $timestamp\n";
if (0 && scalar(@ARGV) == 0) {
    print `grep -E "^#:#" $0 | cut -b3-`;
    exit;
}
my $debug = 0;
while (scalar(@ARGV) > 0 and ($ARGV[0] =~ m{\A[\-\+]})) {
    my $opt = shift(@ARGV);
    if (0) {
    } elsif ($opt  =~ m{d}) {
        $debug     = shift(@ARGV);
    } else {
        die "invalid option \"$opt\"\n";
    }
} # while $opt

# while (<DATA>) {
while (<>) {
    s/\s+\Z//; # chompr
    next if ! m{\AA\d+};
    my $line = $_;
    my ($aseqno, $callcode, @parms) = split(/\t/, $line);
    $parms[3] = $parms[1];
    $parms[2] = "";
    my $code = "u"; 
    #                 1    1
    while($parms[1] =~ s{(X\d+)}{$code}) {
        $parms[2] .= ",$code=$1";
        $code = chr(ord($code) + 1);
    }
    $parms[2] = substr($parms[2], 1); # remove leading ","
    print join("\t", $aseqno, $callcode, @parms) ."\n";
} # while
__DATA__
A367959	decexp	0	(Pi/2)*X308716
A367959	decexp	0	X308715-X049006
A367976	decexp	0	(1+X090986)/2
A368211	decexp	0	(-8*exp(-Pi/16)*X292863^8+sqrt(X292862^24/X292863^8+64*exp(-Pi/8)*X292863^16))^(1/8)
A369522	decexp	0	X083679/X016578
A369881	decexp	0	X092605/2
A370000	decexp	0	X226735-13*zeta(3)/18
A370325	decexp	0	X001113*X201776
