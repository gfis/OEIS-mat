# Write several records for lists of equations
# @(#) $Id$
# 2024-06-05, Georg Fischer:
#
#:# Usage:
#:#   perl merge.pl [-d debug] -c fieldno input.seq4 > output.seq4
#:#       -c number of field to be replaced (1, 2, ...; default 4)
#--------------------------------------------------------
use strict;
use integer;
use warnings;
my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime (time);
my $timestamp = sprintf ("%04d-%02d-%02d %02d:%02d", $year + 1900, $mon + 1, $mday, $hour, $min);
my $pwd = `pwd`;
$pwd =~ m{(/OEIS\-mat\S*)};
print "# Generated by ..$1/$0 at $timestamp\n";
if (0 && scalar(@ARGV) == 0) {
    print `grep -E "^#:#" $0 | cut -b3-`;
    exit;
}
my $debug = 0;
my $column = 4;
while (scalar(@ARGV) > 0 and ($ARGV[0] =~ m{\A[\-\+]})) {
    my $opt = shift(@ARGV);
    if (0) {
    } elsif ($opt  =~ m{d}) {
        $debug     = shift(@ARGV);
    } elsif ($opt  =~ m{c}) {
        $column    = shift(@ARGV);
    } else {
        die "invalid option \"$opt\"\n";
    }
} # while $opt

while (<>) {
    next if ! m{\AA\d+\s};
    s/\s+\Z//; # chompr
    my $line = $_;
    my (@fields) = split(/\t/, $line);
    my $eqnlist = $fields[$column]; # next field behind -c
    foreach my $eqn (split(/\,/, $eqnlist)) {
        my ($var, $value) = split(/\=/, $eqn);
        $fields[$column - 1] =~ s{(\W)$var(\W)}{$1$value$2}g;
    }
    print join("\t", @fields) ."\n";
} # while
__DATA__
A246726	decexp	0	u.-(1).inverse()	u=X214726	1/(X214726-1)
A364806	decexp	0	u.-(1).inverse()	u=X359187	1/(X359187-1)
A347407	decexp	0	u.-(2).inverse()	u=X098801	1/(X098801-2)
A359057	decexp	0	CR.ONE.-(u.^(v.negate())).inverse()	u=X001113,v=X001620	1/(1-X001113^(-X001620))
A362922	decexp	0	u.*(2).-(2).inverse()	u=X160389	1/(2*X160389-2)
