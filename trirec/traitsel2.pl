#!perl

# Select a subset of traits: LeftSide or Rightside == 1
# @(#) $Id$
# 2022-10-03, Georg Fischer: copied from traitsel.pl
#
#:# Usage:
#:#   perl traitsel2.pl [-d debog] [-lr|rl] > output.seq4
#:#       -d   debugging mode
#:#       -lr  left=gen, right=1 (default)
#:#       -rl  left=1, right=gen (transpose)
#--------------------------------------------------------
use strict;
use integer;
use warnings;
my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime (time);
my $timestamp = sprintf ("%04d-%02d-%02d %02d:%02d:%02d", $year + 1900, $mon + 1, $mday, $hour, $min, $sec);
print "# generated by trirec/traitsel.pl $timestamp\n";

my @parms;
my %abbrev = qw(ls LeftSide rs RightSide co Constant di Diff ic InnerConstant pa Pascal ip InnerPascal id InnerDiff);
my %subset = ();

if (scalar(@ARGV) == 0) {
    print `grep -E "^#:#" $0 | cut -b3-`;
    exit;
}
my $debug  = 0;
my $mode   = "lr";
my $abbs   = "ls,rs";
my $ofter_file = "../common/joeis_ofter.txt";
while (scalar(@ARGV) > 0 and ($ARGV[0] =~ m{\A[\-\+]})) {
    my $opt = shift(@ARGV);
    if (0) {
    } elsif ($opt  =~ m{d}) {
        $debug     = shift(@ARGV);
    } elsif ($opt  =~ m{lr}) {
        $mode      = "lr";
    } elsif ($opt  =~ m{rl}) {
        $mode      = "rl";
    } elsif ($opt  =~ m{s}) {
        $abbs      = shift(@ARGV);
    } else {
        die "invalid option \"$opt\"\n";
    }
} # while $opt
#----------------
my $aseqno;
my $offset = 1;
my $terms;
my $main_trait; # the last trait to be selected is the main one
foreach my $abb (split(/\W+/, $abbs)) {
    $main_trait = $abbrev{$abb};
    if (! defined($main_trait)) {
        die "**traisel.pl: invalid trait abbreviation \"$abb\"\n";
    } else {
        $subset{$main_trait} = 1;
    }
} # foreach $abb
$subset{"Name"} = 1; # "Name" is always selected

my $buffer = "";
my ($trait, $len, $list);
my $oseqno = "";
my $main_len = 0;
my $keep = 1; # whether to keep the block
# while (<DATA>) {
while (<>) {
    my $line = $_;
    $line =~ s{\s+\Z}{}; # chompr
    if ($line =~ m{\A(A\d+)}) {
        $line =~ s{\t[\.\_]+}{\t}g;
        ($aseqno, $trait, $len, $list) = split(/\t/, $line, -1);
        if ($aseqno ne $oseqno) { # group change
            &output();
            $oseqno = $aseqno;
            $buffer = "";
            $main_len = 0;
            $keep = 1;
        }
        if (0) {
        } elsif ($mode eq "lr") {
            if (defined($subset{$trait})) { # in subset
                $buffer .= "$line\n";
                if (0) {
                } elsif ($trait eq "LeftSide") {
                    if ($list =~ m{\A1(\,1)+\Z}) {
                        $keep = 0; # exclude block if ls eq "1,1,1...1"
                    }
                } elsif ($trait eq "RightSide") {
                    if ($debug >= 1) {
                        print join("\t", "# $trait", "\"$list\"") . "\n";
                    }
                    if ($list !~ m{\A1(\,1)+\Z}) {
                        $keep = 0; # exclude block if rs ne "1,1,1...1"
                    }
                }
            } # in subset
            # lr
        } elsif ($mode eq "rl") { # opposite condition
            if (defined($subset{$trait})) { # in subset
                $buffer .= "$line\n";
                if (0) {
                } elsif ($trait eq "LeftSide") {
                    if ($list !~ m{\A1(\,1)+\Z}) {
                        $keep = 0; # exclude block if ls ne "1,1,1...1"
                    }
                } elsif ($trait eq "RightSide") {
                    if ($debug >= 1) {
                        print join("\t", "# $trait", "\"$list\"") . "\n";
                    }
                    if ($list =~ m{\A1(\,1)+\Z}) {
                        $keep = 0; # exclude block if rs eq "1,1,1...1"
                    }
                }
            } # in subset
            # rl
        }
    } # with aseqno
} # while <>
&output(); # fictive group change at the end
#----
sub output {
    if ($keep > 0) { # long enough
        print $buffer;
        print "#--------\n";
    }
} #output
#----------------
__DATA__
A005145	Pascal	0
A005145	InnerPascal	0
A007318	LeftSide	32	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
A007318	RightSide	32	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
A007318	Border	30	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
A007318	Constant	0
A007318	InnerConstant	0
A007318	Pascal	1	1
A007318	InnerPascal	1	1
A007723	LeftSide	32	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
A007723	RightSide	32	1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2
A007723	Border	0
