#!perl

# Extract row sum relations from CAT25
# @(#) $Id$
# 2021-10-29, Georg Fischer
#
#:# Usage:
#:#   perl rowsums.pl [-d debug] [-f ofter_file] [-r|-c|-s] jcat25.txt > outfile
#:#       -r      extract row sums
#:#       -c      extract columns k
#:#       -s      extract selection (column k, diagonal k)
#:#       -f file with aseqno, offset1, terms (default $(COMMON)/joeis_ofter.txt)
#--------------------------------------------------------
use strict;
use integer;
use warnings;
my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime (time);
my $timestamp = sprintf ("%04d-%02d-%02d %02d:%02d", $year + 1900, $mon + 1, $mday, $hour, $min);
print "# generated by trirec/rowsums.pl at $timestamp\n";

my $debug = 0;
my $ofter_file = "../common/joeis_ofter.txt";
my $mode = "r"; # row sums
my $callcode = "rowsums";
while (scalar(@ARGV) > 0 and ($ARGV[0] =~ m{\A[\-\+]})) {
    my $opt = shift(@ARGV);
    if (0) {
    } elsif ($opt   =~ m{c}) {
        $mode       = "c";
        $callcode   = "tricolk";
    } elsif ($opt   =~ m{d}) {
        $debug      = shift(@ARGV);
    } elsif ($opt   =~ m{\-f}  ) {
        $ofter_file = shift(@ARGV);
    } elsif ($opt   =~ m{[\?h]}) {
        print `grep -E "^#:#" $0 | cut -b3-`;
        exit;
    } elsif ($opt   =~ m{r}) {
        $mode       = "r";
        $callcode   = "rowsums";
    } elsif ($opt   =~ m{s}) {
        $mode       = "s";
        $callcode   = "triselect";
    } else {
        die "invalid option \"$opt\"\n";
    }
} # while $opt
#----------------
my $aseqno;
my $offset = 1;
my $terms;
my %ofters = ();
open (OFT, "<", $ofter_file) || die "cannot read $ofter_file\n";
while (<OFT>) {
    s{\s+\Z}{};
    ($aseqno, $offset, $terms) = split(/\t/);
    $terms = $terms || "";
    if ($offset < -1) { # offsets -2, -3: strange, skip these
    } else {
        $ofters{$aseqno} = "$offset";
    }
} # while <OFT>
close(OFT);
print STDERR "# $0: " . scalar(%ofters) . " jOEIS offsets and some terms read from $ofter_file\n";
#----------------
my %ordinals = qw(
    first     1 main 1 
    second    2 
    third     3 
    fourth    4 
    fifth     5 
    sixth     6 
    seventh   7 
    eighth    8 
    ninth     9 
    tenth    10 
    eleventh 11 
    twelfth  12
    );

# while (<DATA>) {
while (<>) {
    if (m{^[\%\?][NFCY]}) {
        my $line = $_;
        $line =~ s/\s+\Z//; # chompr
        $line =~ m{^\S+ (A\d+) ?(.*)};
        $aseqno = $1;
        my $name   = $2;
        my $choice = 0;
        my $rseqno = "";
        my $colno  = -1;
        if (0) {
        } elsif ($mode eq "r" && $name =~ m{row sum}i) {
            if (0) {
            } elsif ($name =~ m{[Rr]ow sums? (of|for)[^A\.\,]*(A\d+)}) {
                $rseqno = $2;
                $choice = 1;
            } elsif ($name =~ m{[Rr]ow sums?( give| are| form| in| sequence is| yield| equal| *[\:\=])[^A\.\,]*(A\d+)}) {
            #                              1                                                         1         2    2
                $rseqno = $2; my $temp = $aseqno; $aseqno= $rseqno; $rseqno = $temp;
                $choice = 2;
            } elsif ($name =~ m{(A\d+) *\(row sums\)}) {
                $rseqno = $1; my $temp = $aseqno; $aseqno= $rseqno; $rseqno = $temp;
                $choice = 3;
            } elsif ($name =~ m{\(row sums\) *(A\d+)}) {
                $rseqno = $1; my $temp = $aseqno; $aseqno= $rseqno; $rseqno = $temp;
                $choice = 4;
            } elsif ($name =~ m{[Rr]ow sums +(A\d+)}) { # imply: "are"
            #                              1                   1     2    2
                $rseqno = $1; my $temp = $aseqno; $aseqno= $rseqno; $rseqno = $temp;
                $choice = 5;
            }
            # contained "row sum"
        } elsif ($mode eq "c" && $name =~ m{column}i) {
            if (0) {
            } elsif ($name =~ m{[Cc]olumn (k *\= *)?(\d+) of[^A\.\,]*(A\d+)}) {
                $colno  = $2;
                $rseqno = $3;
                $choice = 7;
            } elsif ($name =~ m{[Cc]olumn (k *\= *)?(\d+) is[^A\.\,]*(A\d+)}) {
                $colno  = $2;
                $rseqno = $3; my $temp = $aseqno; $aseqno= $rseqno; $rseqno = $temp;
                $choice = 8;
            }
            # contained "column"
        } elsif ($mode eq "s") && $name =~ m{column|diagonal}i) {
            if (0) {
            } elsif ($name =~ m{[Cc]olumn (k *\= *)?(\d+) of[^A\.\,]*(A\d+)}) {
                $colno  = $2;
                $rseqno = $3;
                $choice = 7;
            } elsif ($name =~ m{[Cc]olumn (k *\= *)?(\d+) is[^A\.\,]*(A\d+)}) {
                $colno  = $2;
                $rseqno = $3; my $temp = $aseqno; $aseqno= $rseqno; $rseqno = $temp;
                $choice = 8;
            } elsif ($name =~ m{(Main|First|Second|Third) +diagonal +of[^A\.\,]*(A\d+)}i) {
                $colno  = $ordinals{lc($1) - 1};
                $rseqno = $2;
                $choice = 9;
            } elsif ($name =~ m{(Main|First|Second|Third) +diagonal +is[^A\.\,]*(A\d+)}i) {
                $colno  = $ordinals{lc($1)};
                $rseqno = $3; my $temp = $aseqno; $aseqno= $rseqno; $rseqno = $temp;
                $choice = 10;
            }
            # contained "column"
        } 
        if (0) {
        } elsif ($choice > 0) {
            if (! defined($ofters{$aseqno}) && defined($ofters{$rseqno})) {
                my $roffset = $ofters{$rseqno};
                my $distk = $roffset == 0 ? 0 : 1;
                print        join("\t", $aseqno, $callcode, 0, $rseqno  , $colno - $distk, $roffset - $distk, "$choice  ", $name) . "\n";
            } elsif (! defined($ofters{$aseqno})) {
                print STDERR join("\t", $aseqno, "later  ", 0, $rseqno  , $colno, $choice
                    . (defined($ofters{$aseqno}) ? "+" : "-")
                    . (defined($ofters{$rseqno}) ? "+" : "-")
                    , $name) . "\n";
            }
        } else {
                print STDERR join("\t", $aseqno, "xx     ", 0, "       ", $colno, $choice
                    . (defined($ofters{$aseqno}) ? "+?" : "- ")
                    , $name) . "\n";
        }
    } # proper CAT25 line type
} # while <>
#--------------------------------------------
__DATA__
%Y A346704 A056239 adds up prime indices, row sums of A112798.
%Y A346730 Row sums give A011782.
%Y A346743 Cf. A002884 (row sums), A346019.
%Y A346772 Row sums of A120057.
%Y A346864 Row sums give A014105, n >= 1.
%Y A346871 Row sums give A000040.
%Y A346872 Row sums give A000079.
%Y A346873 Row sums give A000217, n >= 1.
%Y A346874 Row sums give A000225, n >= 1.
%Y A346875 Row sums give A000384, n >= 1.
%Y A346876 Row sums give A000396.
%Y A347010 Cf. A002416 (row sums), A346082 (main diagonal).
%Y A347043 A056239 adds up prime indices, row sums of A112798.
%Y A347044 A056239 adds up prime indices, row sums of A112798.
%Y A347045 A056239 adds up prime indices, row sums of A112798.
%Y A347046 A056239 adds up prime indices, row sums of A112798.
%C A347171 Row sum n is the sum of GRS terms from j = 0 to 2^n-1 inclusive, which Brillhart and Morton (Beispiel 6 page 129) show is A020986(2^n-1) = 2^ceiling(n/2) = A060546(n).  The same follows by substituting y=1 in the P_n recurrence or the generating function.
%Y A347171 Cf. A060546 (row sums), A104969 (row sums squared terms).
%F A347287 a(n) = row sum of 2^(m-1) where m are terms in row n of A347285.
%Y A347519 Row sums give A208981.
%Y A090174 Row sums give A091564.

%C A253002 Column 6 of A253004
%C A253003 Column 7 of A253004
%Y A253004 Column 1 is A000292(n-3)
%Y A253004 Column 2 is A100157(n-3)
%C A253008 Column 5 of A253011
%C A253009 Column 6 of A253011
%C A253010 Column 7 of A253011
%Y A253011 Column 1 is A000292(n-3)
