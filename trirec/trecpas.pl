#!perl

# Extract recurrences from trecpas.tmp
# @(#) $Id$
# 2022-05-19, Georg Fischer: copied from trirecur.pl
#
#:# Usage:
#:#   perl trecpas.pl [-d debug] trecpas.tmp > outfile
#--------------------------------------------------------
use strict;
use integer;
use warnings;
my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime (time);
my $timestamp = sprintf ("%04d-%02d-%02d %02d:%02d", $year + 1900, $mon + 1, $mday, $hour, $min);
print "# generated by trirec/trecpas.pl at $timestamp\n";

my $debug = 0;
my $mode = "r"; # row sums
my $callcode = "trecpas";
while (scalar(@ARGV) > 0 and ($ARGV[0] =~ m{\A[\-\+]})) {
    my $opt = shift(@ARGV);
    if (0) {
    } elsif ($opt   =~ m{d}) {
        $debug      = shift(@ARGV);
    } else {
        die "invalid option \"$opt\"\n";
    }
} # while $opt

# while (<DATA>) {
while (<>) {
    s/\s+\Z//; # chompr
    s/ for /\tfor\:/; 
    my ($aseqno, $dummy, $offset, $name, @rest) = split(/\t/, $_);
    $name =~ s/ //g; 
    $name =~ s/T\(n\,k\)\=//;
    $name =~ s/T\(n\-1\,k\)/V/; 
    $name =~ s/T\(n\-1\,k\-1\)/U/; 
    my ($n1, $n2) = split(/[\,\;]/, $name);
    if (defined($n2)) {
        unshift(@rest, $n2);
    }
    my $U = "";
    my $V = "";
    $n1 = $n1 || "";
    my @parts = split(/([UV])/, $n1);
    for (my $ipart = 0; $ipart < scalar(@parts); $ipart ++) {
        $parts[$ipart] =~ s{\*\Z}{};
        if (0) {
        } elsif ($parts[$ipart] eq "U") {
            $U = $parts[$ipart - 1];
        } elsif ($parts[$ipart] eq "V") {
            $V = $parts[$ipart - 1];
        } else {
            $parts[$ipart] =~ s{\A\+}{};
            $parts[$ipart] =~ s{([\*\+\-\/])}{ $1 }g;
            
        }
    } # for $ipart
    print join("\t", $aseqno, $callcode, $offset, &polish($U), &polish($V), "", $name, @rest) . "\n";
} # while <>
#----
sub polish {
    my ($expr) = @_;
    $expr =~ s{(\d+)([a-z\(])}{$1\*$2}g;
    $expr =~ s{binomial}{Binomial\.binomial}ig;
    $expr =~ s{Fibonacci}{Fibonacci\.fibonacci}ig;
    if (0) {
    } elsif ($expr =~ s{\^(\d+) *\+\Z}{\.pow\($1\)}g) {
    } elsif (length($expr) > 0) {
        $expr = ".multiply" . (($expr =~ m{\A\(.*\)\Z}) ? $expr : "($expr)");
    }
    return $expr;
} # polish
#--------------------------------------------
__DATA__
A075856	trecpas	0	(n-1)*V+(n+k-1)*U
A080248	trecpas	0	(k*(k+1)/2)*V+U,T(n,n)=1
A088996	trecpas	0	n*U+(n-1)*V;T(0,0)=1,T(0,k)=0	for:k>0,T(n,k)=0fork<0
A090238	trecpas	0	U+((n+k-1)/k)*V;T(0,0)=1,T(n,0)=0	for:n>0,T(0,k)=0fork>0
A090971	trecpas	0	(V+U)mod2
A091441	trecpas	0	k*U+(n-k+1)*V,T(1,1)=1
A094645	trecpas	0	U+(n-2)*V	for:n>=k>=0;T(n,k)=0forn<k;T(n,-1)=0;T(0,0)=1
A094646	trecpas	0	U+(n-3)*V;T(n,k)=0	for:n<m,T(n,-1)=0,T(0,0)=1
A098436	trecpas	0	k^3*V+U,T(0,0)=1
A100861	trecpas	0	(n-2k+1)U+V
A102365	trecpas	0	(n-k)*U+(2*k+1)*V	for:T(0,0)=1,T(0,k)=0fork>0,T(n,k)=0fork<0
A102625	trecpas	0	k*U+(2*n-k)*V
A103450	trecpas	0	U+V+binomial(n-2,k-1)	for:T(n,0)=1
A111577	trecpas	0	U+(3k-2)*Vreadbyrows
A111577	trecpas	0	U+(3k-2)*V
A111636	trecpas	0	2^k*V+2^(n-k)*U
A119687	trecpas	0	U^2+V^2;T(0,0)=1;T(n,-1)=0;T(n,k)=0,n<k
A119731	trecpas	0	U^3+V^3;T(0,0)=1;T(n,k)=0	for:k<0orfork>n
A125172	trecpas	0	U+V,k>1
A125235	trecpas	0	U+V,k>1
A127156	trecpas	0	V+U	for:n,k>=1
A128134	trecpas	0	V+U+binomial(n-1,k-1)	for:2<=k<=nfor(n,k)<>(2,2)
A132159	trecpas	0	(n-k+1)*V+U
