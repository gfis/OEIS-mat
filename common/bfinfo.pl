#!perl

# Extract information from a b-file, and generate .tsv or SQL
# @(#) $Id$
# 2019-01-22, Georg Fischer: copied from ../bfcheck/bfanalyze.pl
#
# usage:
#   perl bfinfo.pl [-action] [-l lead] [-d level] inputdir > outputfile
#       action  (default -br) 
#			a	for sequence JSON
#			b	for bfile
#          	r	TSV for Dbat -r, 
#          	c 	generate CREATE SQL
#          	i	generate INSERT SQL
#			u	generate UPDATE SQL
#       -l lead		print so many initial terms (default 8)
#		-d level	debug level none(0), some(1), more(2)
#       -w width    maximum number of characters in term string
#       inputdir 	default: ./unbf
#---------------------------------
use strict;
use integer;
my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime (time);
my $TIMESTAMP = sprintf ("%04d-%02d-%02dT%02d:%02d:%02d+00:00"
        , $year + 1900, $mon + 1, $mday, $hour, $min, $sec);

# get options
my $action  = "br"; # generate TSV for Dbat -r
my $debug   =  0; # 0 (none), 1 (some), 2 (more)
my $imin    =  0;
my $imax    = -1; # unknown
my $lead    =  8; # so many initial terms are printed
my $width   = 64;
my $tabname = "bfinfo";
while (scalar(@ARGV) > 0 and ($ARGV[0] =~ m{\A\-})) {
    my $opt = shift(@ARGV);
    if (0) {
    } elsif ($opt =~ m{\-d}) {
        $debug  = shift(@ARGV);
    } elsif ($opt =~ m{\-l}) {
        $lead  = shift(@ARGV);
    } elsif ($opt =~ m{\-}) {
        $action = $opt;
    } else {
        die "invalid option \"$opt\"\n";
    }
} # while ARGV
my $inputdir = shift(@ARGV);
$tabname = ($action =~ m{b}) 
	? "bfinfo"
	: "asinfo"
	;
my $access; # modification timestamp from the file
my $buffer; # contains the whole file
#----------------------------------------------
if (0) {
} elsif (($action =~ m{c}) and ($action =~ m{b})) {
   print <<"GFis";
-- Table for OEIS - basic information about b-files
-- @(#) \$Id\$
-- $TIMESTAMP: Georg Fischer - generated by bfinfo.pl -c $tabname, do not edit here!
--
DROP    TABLE  IF EXISTS $tabname;
CREATE  TABLE            $tabname
    ( aseqno  VARCHAR(10)  -- A322469
    , bfimin  BIGINT
    , bfimax  BIGINT
    , access  TIMESTAMP
    , mess    VARCHAR(64)
    , terms   VARCHAR(64)
    , PRIMARY KEY(aseqno)
    );
COMMIT;
GFis
} elsif ($action =~ m{i}) {
	die "action $action not yet implementen\n";
} elsif ($action =~ m{u}) {
	die "action $action not yet implementen\n";
} elsif ($action =~ m{r}) {
	my @files = glob("$inputdir/*");
	foreach my $file (@files) {
		my @info = ($action =~ m{b}) 
			? &get_bfinfo($file)
			: &get_asinfo($file)
			;
		print join("\t", @info) . "\n";
	} # foreach $file
} else {
	die "invalid action \"$action\"\n";
} # actions
#----------------------
sub read_file { # returns in global $access, $buffer
    my ($filename) = @_;
    open(FIL, "<", $filename) or die "cannot read $filename\n";
    my ($dev, $ino, $mode, $nlink, $uid, $gid, $rdev, $size, $atime
    	, $mtime, $ctime, $blksize, $blocks) = stat(FIL);
	($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime ($mtime);
	$access = sprintf ("%04d-%02d-%02d %02d:%02d:%02d"
        , $year + 1900, $mon + 1, $mday, $hour, $min, $sec); 
    read(FIL, $buffer, 100000000); # 100 MB, should be less than 10
    close(FIL);
} # read_file
#----
sub get_asinfo { # read JSON of 1 sequence
    my ($filename) = @_;
    &read_file($filename);
} # asinfo
#----
sub get_bfinfo {
    my ($filename) = @_;
    &read_file($filename);
    my $terms  = "";
    my $bfimin = 0;
    my $bfimax = 0;
    my $iline  = 0;
    my $mess   = "";
    foreach my $line (split(/\n/, $buffer)) {
        $line  =~ s{\A\s*(\#.*)?}{}o; # remove leading whitespace and comments
        if ($line =~ m{\A(-?\d+)\s+(\-?\d{1,})\s*(\#.*)?\Z}o) { 
            # loose    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  format "index term #?"
            my ($index, $term) = ($1, $2);
            if ($iline == 0) {
            	$bfimin = $index;
            } elsif ($index != $bfimax + 1) { # check for increasing only
                if ($mess !~ m{ ninc}) {
                    $mess .= " ninc\@" . substr($line, 0, 8);
                }
            } # not increasing
            if ($iline < $lead and length($terms) + length($term) < 64) { # store the leading ones
                $terms .= ",$term";
            } 
            if ((substr($index, 0, 1) eq "-" or substr($term, 0, 1) eq "-") 
                    and ($mess !~ m{ sign})) {
                $mess .= " sign";
            }
            $bfimax = $index;
            $iline ++;
            # line with parseable term
        } elsif (length($line) == 0) { 
        	# was comment or whitespace
        } else { # bad
            if ($mess !~ m{ ndig}) { # not exactly 2 numbers
               $mess .= " ndig\@" . substr($line, 0, 8)
            }
        }
    } # foreach $line
    $filename =~ m{b(\d{6})\.txt}i; # extract seqno
    my $aseqno = "A$1";
    if (length($mess) > 0 and ($mess =~ m{ n(dig|inc)})) {
        print STDERR "# $filename: $aseqno\t$mess\n";
    }
    return ($aseqno, $bfimin, $bfimax, $access, substr($mess, 1), substr($terms, 1));
} # get_info
__DATA__
