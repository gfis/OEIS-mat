#!perl

# Extract XREF information from a CAT25 file
# @(#) $Id$
# 2025-10-19: standalone, extracted from extract_info.pl
# 2019-01-22, Georg Fischer
#
#:# usage:
#:#   perl extract_xref.pl [-d mode] cat25.txt > asxref.txt
#:#   perl extract_xref.pl [-d mode] -c        > asxref.create.sql
#:#       -d mode    debug mode: none(0), some(1), more(2)
#---------------------------------
use strict;
use integer;
my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime (time);
my $utc_stamp = sprintf ("%04d-%02d-%02dT%02d:%02d:%02d\z"
        , $year + 1900, $mon + 1, $mday, $hour, $min, $sec);

# get options
my $in_xref;         # whether in "xref" property
my $do_xref = 0;     # whether in action -ax
my $debug      =  0; # 0 (none), 1 (some), 2 (more)
my %xhash;           # for &extract_aseqnos
my $aseqno;
my $tabname = "asxref";
while (scalar(@ARGV) > 0 and ($ARGV[0] =~ m{\A\-})) {
    my $opt = shift(@ARGV);
    if (0) {
    } elsif ($opt =~ m{\-d}) {
        $debug    = shift(@ARGV);
    } elsif ($opt =~ m{\-c}) {
        &print_create_asxref();
        exit;
    } else {
        die "invalid option \"$opt\"\n";
    }
} # while ARGV
#----
my $line;
my $type;
# while (<DATA>) {
while (<>) {
    s/\s+\Z//;
    $type     = substr($_, 1, 1);
    $line     = substr($_,3);
    my $nseqno   = 'A' . substr($line, 1, 7);
    if (0) {
    } elsif ($type eq "I") { # new sequence
        &output_xref();
        $aseqno = $nseqno;
    } elsif ($type eq "Y") {
        $in_xref = 1; # start xref mode
        &extract_aseqnos($aseqno, $line);
    } else {
        $in_xref = 0; # outside xref mode
        &extract_aseqnos($aseqno, $line);
    }
} # while <>
&output_xref();
#----
sub output_xref {
    foreach my $key (sort(keys(%xhash))) {
    print join("\t", ($aseqno
        , $key
        , $xhash{$key}  )) . "\n";
    } # foreach
    %xhash = (); # bits 1: in xrefs, bit 0: elsewhere
} # output_xref
#-----------------------
sub extract_aseqnos { # for xref
    my ($aseqno, $line) = @_;
    $line =~ s{€}{A}g;
    if (1) {
        foreach my $aref ($line =~ m{(A\d{6})}g) { # get all referenced A-numbers
            if ($aref eq $aseqno) { # ignore reference to own
            } elsif (! defined($xhash{$aref})) {
                $xhash{$aref}  = ($in_xref == 1 ? 2 : 1);
            } else {
                $xhash{$aref} |= ($in_xref == 1 ? 2 : 1);
            }
        } # foreach
    }
    if ($in_xref == 1) {
      foreach my $pair ($line =~ m{A(\d{6}\-A\d{6})}g) { # get Ammmmmm-Annnnnn
        my ($lo, $hi) = split(/\-A/, $pair);
        if ($lo + 64 > $hi) {
          for (my $seqno = $lo + 1; $seqno < $hi; $seqno ++) {
            my $aref = sprintf("A%06d", $seqno);
            if ($aref eq $aseqno) { # ignore reference to own
            } elsif (! defined($xhash{$aref})) {
                $xhash{$aref}  = ($in_xref == 1 ? 2 : 1);
            } else {
                $xhash{$aref} |= ($in_xref == 1 ? 2 : 1);
            }
          } # for $seqno
        } # if limit
      } # foreach
    } # in_xref
} # extract_aseqnos
#----
sub print_create_asxref {
    print <<"GFis";
--  Table for OEIS - information about CROSSREFS in sequences
--  @(#) \$Id\$
--  $utc_stamp: Georg Fischer - generated by extract_xref.pl - do NOT edit here!
--
DROP    TABLE  IF EXISTS $tabname;
CREATE  TABLE            $tabname
    ( aseqno    VARCHAR(10)   -- A322469
    , rseqno    VARCHAR(10)   -- referenced A-number
    , mask      INT           -- bit 1: in "xref", bit 0: in other properties
    , PRIMARY KEY(aseqno, rseqno, mask)
    );
CREATE  INDEX  ${tabname}a ON $tabname
    (aseqno     ASC
    );
CREATE  INDEX  ${tabname}r ON $tabname
    (rseqno     ASC
    );
COMMIT;
GFis
} # print_create_asxref
#----
__DATA__
%I A389847 #9 Oct 17 2025 09:57:54
%S A389847 1,0,0,6,72,720,8280,120960,2116800,41610240,903571200,21674822400,
%T A389847 571548700800,16417540339200,509709674073600,17011056372710400,
%U A389847 607616125788672000,23133198948507648000,935196923565557452800,40010432908461913497600,1806175046642174208000000
%N A389847 E.g.f. A(x) satisfies A(x) = exp(x^3 * A(x) / (1-x)^3).
%F A389847 E.g.f.: exp( -LambertW(-x^3 / (1-x)^3) ).
%F A389847 a(n) = n! * Sum_{k=0..floor(n/3)} (k+1)^(k-1) * binomial(n-1,n-3*k)/k!.
%o A389847 (PARI) a(n) = n!*sum(k=0, n\3, (k+1)^(k-1)*binomial(n-1, n-3*k)/k!);
%Y A389847 Cf. A367789, €389844.
%Y A389847 Cf. A361572, A387951.
%K A389847 nonn,new
%O A389847 0,4
%A A389847 _Seiichi Manyama_, Oct 17 2025
%I A389853 #12 Oct 18 2025 02:34:00
%S A389853 14,29,47,53,71,73,179,277,311,349,353,599,613,643,1117,1123
%N A389853 Numbers k such that both 2^k-1 and 2^k+1 are sphenic.
%e A389853 14 is a term: 2^14-1 = 16383 = 3*43*127 and 2^14+1 = 16385 = 5*29*113.
%p A389853 q:= n-> andmap(x-> ifactors(x)[2][.., 2]=[1$3], [2^n-1, 2^n+1]):
%p A389853 select(q, [$1..200])[];  # _Alois P. Heinz_, Oct 17 2025
%t A389853 Select[Range[180], AllTrue[2^# + {-1, 1}, And[SquareFreeQ[#], PrimeNu[#] == 3] &] &]
%Y A389853 Cf. A000051, A000225, A007304, A092558 (both 2^k-1 and 2^k+1 are semiprimes).
%Y A389853 Supersets: €262978, €389854.
%K A389853 nonn,hard,more,new
%O A389853 1,1
%A A389853 _Michael De Vlieger_, Oct 17 2025
