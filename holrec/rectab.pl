#!perl

# Process MMA RecurrenceTable calls and extract parameters for HolonomicSequence
# @(#) $Id$
# 2019-12-02, Georg Fischer
#
#:# Usage:
#:#   perl rectab.pl mmart3.tmp > holonomic.tmp
#---------------------------------
use strict;
use integer;
use warnings;
my $version = "V1.1";
my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime (time);
my $timestamp = sprintf ("%04d-%02d-%02d %02d:%02d:%02d"
        , $year + 1900, $mon + 1, $mday, $hour, $min, $sec);

my $debug  = 0;
while (scalar(@ARGV) > 0 and ($ARGV[0] =~ m{\A[\-\+]})) {
    my $opt = shift(@ARGV);
    if (0) {
    } elsif ($opt  =~ m{d}) {
        $debug  = shift(@ARGV);
    } else {
        die "invalid option \"$opt\"\n";
    }
} # while $opt

print "# Generated by OEIS-mat/linrec/rectab.pl on $timestamp\n";
while (<>) {
    next if ! m{\AA\d};
    s{\s+\Z}{}; # chompr
    my ($aseqno, $callcode, $offset, $line) = split(/\t/, $_);
    $line =~ s{\(\*.*}{};
    $line =~ s{\s}{}g;
    print "$aseqno\t# $line\n" if $debug >= 1;
    my $join = "";
    if ($line =~ m{\AJoin\[\{([0-9\-\,]+)\}\,}) {
        $join = ",$1";
        $line =~ s{\AJoin\[\{([0-9\-\,]+)\}\,}{}; $line =~ s{\]\Z}{};
    }
    if ($line =~ m{\ARecurrenceTable\[\{([^\}]+)\}\,(\w+)\,\{([^\}]+)\}\]}) {
        my $exprlist = $1;
        my $variable = $2;
        my $range    = $3;
        $exprlist =~ s{a\[\-(\d+)\+n\]}{a\[n\-$1\]}g;
        $exprlist =~ s{a\[(\d+)\+n\]}{a\[n\+$1\]}g;
        if ($exprlist =~ m{([a-z]\[\-?\d+\](\=+[a-z]\[\-?\d+\])+)\=+(\-?\d+)}) { # chained assignments
            # expand to single assignments
            my $list  = $1;
            my $value = $3;
            my @arrs  = split(/\=+/, $list);
            my $list2 = join("==$value,", @arrs) . "==$value";
            $exprlist =~ s{([a-z]\[\-?\d+\](\=+[a-z]\[\-?\d+\])+)\=+(\-?\d+)}{$list2};
            print "$aseqno\t# list=\"$list\", value=\"$value\", list2=\"$list2\"\n" if $debug >= 1;
        } # if chained assignments
        my %hash = ();
        my $annihil  = "";
        my $nyi = 4;
        # polish the expression list
        $exprlist = &norm_index($exprlist);
        $exprlist =~ s{(n|\d|\))a}{$1\*a}g;
        $exprlist =~ s{(\d|\))n}  {$1\*n}g;
        $exprlist =~ s{(\d)\(}    {$1\*\(}g;
        $exprlist =~ s{n\(}       {n*\(}g;
        $exprlist =~ s{(a\[[n\+\-\d]+\])\*?(\([^\)]+\)(\^\d+)?)}{$2\*$1}g; # a[n-1](n+1)^2 -> reverse factors
        $exprlist =~ s{(a\[[n\+\-\d]+\])\*?(n(\^\d+)?)}{$2\*$1}g; # a[n-1]n^3 -> reverse factors
        my @parts = map {
                if ((m{[A-Zb-mo-z\/\!]}) or (m{\^\D}) or (m{\]\*?a}) or (m{\]\^}) or (m{\]\)}) or (m{\(a}) ) {
                    $nyi = 3;
                }
                $_
            } split(/\,/, $exprlist);
        if ($nyi == 3) {
            print join("\t", $aseqno, "$callcode$nyi", $variable, $range, $exprlist), "\n";
            next;
        }
        foreach my $part (@parts) {
            if (length($part) == 0) {
              # ignore
            } elsif ($part =~ m{\A[a-z]\[(\-?\d+)\]\=\=?(\-?\d+)\Z}) {
                my ($left, $right) = ($1, $2);
                $left = $1;
                $hash{$left} = $right;
                print "$aseqno\t# hash{$left}=$hash{$left}\n" if $debug >= 2;
            } else {
                $annihil = $part;
                if ($annihil !~ m{\=+}) {
                    $annihil .= "=0";
                }
                $annihil =~ s{\=\=}{\=};
                print "$aseqno\t# annihil: $annihil\n" if $debug >= 1;
            }
        } # foreach $part
        my $vector = $join;
        my @skeys  = sort {$a <=> $b} (keys(%hash));
        my $ind    = $skeys[0];
        foreach my $key (@skeys) {
            while ($ind < $key and $ind < 29) {
                $vector .= ",0";
                $ind ++;
            }
            $vector .= ",$hash{$key}";
            $ind ++;
        } # foreach
        $vector =~ s{\A\,}{\[};
        $vector .= "]";
        print join("\t", $aseqno, "$callcode$nyi", $offset, $annihil, $vector, $range), "\n";

        my %hinx = ();
        @parts = # grep { $_ ne "=0" and $_ ne "" }
                split(/\]/, $annihil);
        my $negate = 0;
        # print scalar(@parts) . " parts\n";
        my $const = -29647;
        foreach my $part (@parts) {
            print "$aseqno\t# part=\"$part\"\n" if $debug >= 1;
            my ($poly, $anshift) = split(/\*?a\[n/, $part);
            $hinx{$const} = "0";
            $anshift = $anshift || $const;
            $poly    = $poly    || "+1";
            $poly   =~ s{\A([\-\+])\Z}{${1}1};
            print "$aseqno\t# poly=\"$poly\", anshift=\"$anshift\"\n" if $debug >= 1;
            if (0) {
            } elsif ($poly =~ m{\A\=}) {
                $negate = 1;
                $poly =~ s{\A\=}{\-};
                $poly =~ s{\-\-}{}g;
            } elsif ($poly =~ m{\A\-}) {
                if ($negate == 1) {
                    $poly =~ s{\A\-}{\+};
                }
            } elsif ($poly =~ m{\A\+}) {
                if ($negate == 1) {
                    $poly =~ s{\A\+}{\-};
                }
            }
            $poly =~ s{\A\+}{};
            $poly =~ s{\A\-0\Z}{0};
            $poly =~ s{\A\-\Z}{\-1};
            $poly =~ s{\A\\Z}{1};
            $poly =~ s{\=0\Z}{};
            if ($poly =~ m{([\-\+])\Z}) { # A249916: a[n]==4(n-1)-a[n-3] -> $poly = "-4(n-1)-"
                my $sign = $1;
                $poly = substr($poly, 0, length($poly) - 1); # remove trailing sign
                $hinx{$const} = $poly;
                if ($negate == 1) {
                    $sign = ($sign eq "+") ? "-" : "+";
                }
                $poly = "${sign}1" + 0;
            }
            $hinx{$anshift + 0} = $poly; # "+ 0": remove "+" sign
        } # foreach $part
        my $matrix = "[" . $hinx{$const};
        my @anshifts = (sort { $a <=> $b } (keys(%hinx)));
        print "$aseqno\t# anshifts=" . join(",", @anshifts) . "\n" if $debug >= 1;
        shift(@anshifts); # remove const
        if (scalar(@anshifts) > 0) {
          my $inx0 = $anshifts[0];
          my $inx9 = $anshifts[scalar(@anshifts) - 1];
          print "$aseqno\t# inx0=$inx0, inx9=$inx9\n" if $debug >= 1;
          my $degree = $inx9 - $inx0 + 1;
          $ind = $inx0;
          while ($ind <= $inx9) {
              $matrix .= "," . (defined($hinx{$ind}) ? $hinx{$ind} : "0");
              $ind ++;
          } # while $ind
          $matrix .= "]";
          $matrix =~ s{\A\,}{\[};
          print join("\t", $aseqno, "holo", $offset, $matrix, $vector, $inx9), "\n";
      } # scalar > 0
    } # if RecTab
} # while <>
#--------------------
sub norm_index {
        my ($info) = @_;
        $info =~ s{\[(\-\d+)\+n\]}{\[n$1\]};
        $info =~ s{\[(\d+)\+n\]}{\[n\+$1\]};
        $info =~ s{\[n\]}{\[n\+0\]};
        return $info;
} # norm_index
__DATA__
*)
A050983 mmart   RecurrenceTable[{a[0] == 1, a[1] == 14, 4 (n + 1) (2 n + 1)^3 (48 n^2 + 162 n + 137) a[n] + (n + 2)^3 (2 n + 3) (48 n^2 + 66 n + 23) a[n + 2] == 2 (4 (n + 1)^2 (2 n + 3)^2 (408 n^2 + 969 n + 431) - (n + 1) (2 n + 3) (69 n + 31) + 57 n + 92) a[n + 1]}, a[n], {n, 0, 20}] (* _Vladimir Reshetnikov_, Sep 26 2016 *)
A051285 mmart   RecurrenceTable[{a[1]==1, a[2]==2, a[n]==a[n-1]^a[n-2]}, a, {n, 7}] (* _Vincenzo Librandi_, Dec 17 2015 *)
A051403 mmart   RecurrenceTable[{a[0]==1, a[-1]==0, a[n]==(n+2)(a[n-1]-a[n-2])},a[n],{n,-1,21}] (* _Harvey P. Dale_, Aug 24 2011 *)
A051605 mmart   RecurrenceTable[{a[0]==1,a[n]==(3n+5)a[n-1]},a,{n,20}] (* _Harvey P. Dale_, Oct 19 2013 *)
A051708 mmart   RecurrenceTable[{a[1]==1,a[2]==2,a[n]==((10n-16)a[n-1]-(9n-27)a[n-2])/ (n-1)},a,{n,30}] (* _Harvey P. Dale_, Sep 28 2013 *)
A051786 mmart   RecurrenceTable[{a[1]==a[2]==a[3]==a[4]==1,a[n]==(1+a[n-1]a[n-2]a[n-3])/ a[n-4]},a[n],{n,15}] (* _Harvey P. Dale_, May 14 2011 *)
A052129 mmart   Join[{1},RecurrenceTable[{a[1]==1,a[n]==n a[n-1]^2},a,{n,10}]]  (* _Harvey P. Dale_, Apr 26 2011 *)
A052177 mmart   Flatten[{0,RecurrenceTable[{(n-1)*(n+3)*a[n] == 4*n*(2*n+1)*a[n-1] - 12*(n-1)*n*a[n-2],a[1]==1,a[2]==8},a,{n,20}]}] (* _Vaclav Kotesovec_, Oct 08 2012 *)
A052754 mmart   Join[{0,0,0,0}, RecurrenceTable[{a[4] == 24, a[5] == 120, (n^4 - 6*n^2 - n^3 + 4*n + 8)*a[n] + (7*n - 2*n^3 + n^2 - 6)*a[n + 1] == -(n^2 - n)*a[n + 2]}, a, {n, 4, 30}]] (* _G. C. Greubel_, Sep 05 2018 *)
A052758 mmart   Join[{0,0,0,0}, RecurrenceTable[{a[4] == 24, a[5] == 180, a[6] == 1260, (4*n^4 -n^6 -7*n -9*n^2 -3*n^5 +6 +10*n^3)*a[n] + (3*n^5 +12*n^4 +4*n^3 -13*n^2 +6*n)*a[n+1] +(-12*n^3 -3*n^4 -9*n^2)*a[n+2] == -(n^3 +3*n^2 + 2*n)*a[n+3]}, a, {n, 4, 30}]] (* _G. C. Greubel_, Sep 05 2018 *)
A052766 mmart   Join[{0,0,0,0,0}, RecurrenceTable[{a[5] == 120, a[6] == 720, (n^4 -7*n^2 -3*n^3 +15*n +18)*a[n] + (8*n -2*n^3 +5*n^2 -20)*a[n+1] == -(-3*n +n^2 + 2)*a[n+2]}, a, {n, 5, 30}]] (* _G. C. Greubel_, Sep 05 2018 *)
A053486 mmart   RecurrenceTable[{a[0]==1, a[n]== n*a[n-1] + 3^n}, a, {n, 200}] (* _Vincenzo Librandi_, Nov 15 2012 *)
A053557 mmart   Join[{1, 0}, Numerator[RecurrenceTable[{a[n]==a[n-1]+a[n-2]/(n-2), a[1] ==0, a[2]==1}, a, {n,2,30}]]] (* _Terry D. Grant_, May 07 2017; corrected by _G. C. Greubel_, May 16 2019 *)
A053817 mmart   RecurrenceTable[{a[0]==1,a[n]==n(a[n-1]+n)},a,{n,20}] (* _Harvey P. Dale_, Feb 14 2015 *)
A053871 mmart   RecurrenceTable[{a[0]==1,a[1]==0,a[n]==2(n-1)(a[n-1]+a[n-2])}, a[n],{n,20}] (* _Harvey P. Dale_, Sep 15 2011 *)
A053983 mmart   RecurrenceTable[{a[0]==a[1]==1,a[n]==(2n-1)a[n-1]-a[n-2]},a,{n,20}] (* _Harvey P. Dale_, Dec 21 2011 *)
A053984 mmart   RecurrenceTable[{a[n] == (2*n - 1)*a[n - 1] - a[n - 2], a[0] == 0,
A054516 mmart   RecurrenceTable[{a[n]+(n-3)*a[n-1]==(n-2)*(n-3), a[3]==0}, a, {n,3,30}] (* _G. C. Greubel_, Mar 30 2019 *)
